// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: product.sql

package sqlc

import (
	"context"
	"time"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (id, product_id, name, brand, description, stock, base_price,
                      price_eceran, price_grosir, image, type, created_at, updated_at, created_by, updated_by)
VALUES ((gen_random_uuid()::char(36)), $1::char(36), $2::varchar, $3::varchar,
        $4::varchar, $5::integer, $6::float,
        $7::float, $8::float, $9::varchar, $10::varchar,
        now() at time zone 'Asia/Jakarta', now() at time zone 'Asia/Jakarta', $11::varchar, $12::varchar) returning id
`

type CreateProductParams struct {
	ProductID   string  `json:"product_id"`
	Name        string  `json:"name"`
	Brand       string  `json:"brand"`
	Description string  `json:"description"`
	Stock       int32   `json:"stock"`
	BasePrice   float64 `json:"base_price"`
	PriceEceran float64 `json:"price_eceran"`
	PriceGrosir float64 `json:"price_grosir"`
	Image       string  `json:"image"`
	Type        string  `json:"type"`
	CreatedBy   string  `json:"created_by"`
	UpdatedBy   string  `json:"updated_by"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.ProductID,
		arg.Name,
		arg.Brand,
		arg.Description,
		arg.Stock,
		arg.BasePrice,
		arg.PriceEceran,
		arg.PriceGrosir,
		arg.Image,
		arg.Type,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteProductByID = `-- name: DeleteProductByID :one
DELETE
FROM products
WHERE id = $1::char(36)
    returning id
`

func (q *Queries) DeleteProductByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteProductByID, id)
	err := row.Scan(&id)
	return id, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id::char(36),
        product_id::char(36),
        name::varchar,
        brand::varchar,
        description::varchar,
        stock::integer,
        base_price::float,
        price_eceran::float,
        price_grosir::float,
        image::varchar,
        type::varchar,
        created_at::timestamp,
        updated_at::timestamp,
        created_by::varchar,
        updated_by::varchar
FROM products
WHERE id = $1::char(36)
`

type GetProductByIDRow struct {
	ID          string    `json:"id"`
	ProductID   string    `json:"product_id"`
	Name        string    `json:"name"`
	Brand       string    `json:"brand"`
	Description string    `json:"description"`
	Stock       int32     `json:"stock"`
	BasePrice   float64   `json:"base_price"`
	PriceEceran float64   `json:"price_eceran"`
	PriceGrosir float64   `json:"price_grosir"`
	Image       string    `json:"image"`
	Type        string    `json:"type"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	CreatedBy   string    `json:"created_by"`
	UpdatedBy   string    `json:"updated_by"`
}

func (q *Queries) GetProductByID(ctx context.Context, productid string) (GetProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, productid)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Brand,
		&i.Description,
		&i.Stock,
		&i.BasePrice,
		&i.PriceEceran,
		&i.PriceGrosir,
		&i.Image,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id::char(36),
    product_id::char(36),
    name::varchar,
    brand::varchar,
    description::varchar,
    stock::integer,
    base_price::float,
    price_eceran::float,
    price_grosir::float,
    image::varchar,
    type::varchar,
    created_at::timestamp,
    updated_at::timestamp,
    created_by::varchar,
    updated_by::varchar
FROM products
`

type GetProductsRow struct {
	ID          string    `json:"id"`
	ProductID   string    `json:"product_id"`
	Name        string    `json:"name"`
	Brand       string    `json:"brand"`
	Description string    `json:"description"`
	Stock       int32     `json:"stock"`
	BasePrice   float64   `json:"base_price"`
	PriceEceran float64   `json:"price_eceran"`
	PriceGrosir float64   `json:"price_grosir"`
	Image       string    `json:"image"`
	Type        string    `json:"type"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	CreatedBy   string    `json:"created_by"`
	UpdatedBy   string    `json:"updated_by"`
}

func (q *Queries) GetProducts(ctx context.Context) ([]GetProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.Brand,
			&i.Description,
			&i.Stock,
			&i.BasePrice,
			&i.PriceEceran,
			&i.PriceGrosir,
			&i.Image,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductByID = `-- name: UpdateProductByID :one
UPDATE products
SET name= $1:: varchar,
    product_id= $2:: varchar,
    brand= $3:: varchar,
    description = $4:: varchar,
    stock= $5:: integer,
    base_price = $6:: float,
    price_eceran = $7:: float,
    price_grosir = $8:: float,
    image = $9:: varchar,
    type = $10:: varchar,
    updated_at = (now() at time zone 'Asia/Jakarta'):: timestamp,
    updated_by = $11:: varchar
WHERE id = $12:: char (36) returning id::char(36), product_id::char(36),
    name:: varchar, brand::varchar, description::varchar, stock::integer, base_price::float, price_eceran::float, price_grosir::float
    , image::varchar, type::varchar, created_at::timestamp, updated_at::timestamp, created_by::varchar, updated_by::varchar
`

type UpdateProductByIDParams struct {
	Name        string  `json:"name"`
	ProductID   string  `json:"product_id"`
	Brand       string  `json:"brand"`
	Description string  `json:"description"`
	Stock       int32   `json:"stock"`
	Baseprice   float64 `json:"baseprice"`
	Priceeceran float64 `json:"priceeceran"`
	Pricegrosir float64 `json:"pricegrosir"`
	Image       string  `json:"image"`
	Type        string  `json:"type"`
	Updatedby   string  `json:"updatedby"`
	ID          string  `json:"id"`
}

type UpdateProductByIDRow struct {
	ID          string    `json:"id"`
	ProductID   string    `json:"product_id"`
	Name        string    `json:"name"`
	Brand       string    `json:"brand"`
	Description string    `json:"description"`
	Stock       int32     `json:"stock"`
	BasePrice   float64   `json:"base_price"`
	PriceEceran float64   `json:"price_eceran"`
	PriceGrosir float64   `json:"price_grosir"`
	Image       string    `json:"image"`
	Type        string    `json:"type"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	CreatedBy   string    `json:"created_by"`
	UpdatedBy   string    `json:"updated_by"`
}

func (q *Queries) UpdateProductByID(ctx context.Context, arg UpdateProductByIDParams) (UpdateProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateProductByID,
		arg.Name,
		arg.ProductID,
		arg.Brand,
		arg.Description,
		arg.Stock,
		arg.Baseprice,
		arg.Priceeceran,
		arg.Pricegrosir,
		arg.Image,
		arg.Type,
		arg.Updatedby,
		arg.ID,
	)
	var i UpdateProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Brand,
		&i.Description,
		&i.Stock,
		&i.BasePrice,
		&i.PriceEceran,
		&i.PriceGrosir,
		&i.Image,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}
