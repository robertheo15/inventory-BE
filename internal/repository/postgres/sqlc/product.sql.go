// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: product.sql

package sqlc

import (
	"context"
	"time"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (id, product_id, name, brand, description, base_price,
                      price_eceran, price_grosir, created_at, updated_at, created_by, updated_by)
VALUES ((gen_random_uuid()::char(36)), $1::char(36), $2::varchar, $3::varchar,
        $4::varchar, $5::float,
        $6::float, $7::float,
        now() at time zone 'Asia/Jakarta', now() at time zone 'Asia/Jakarta', $8::varchar, $9::varchar) returning id
`

type CreateProductParams struct {
	ProductID   string  `json:"product_id"`
	Name        string  `json:"name"`
	Brand       string  `json:"brand"`
	Description string  `json:"description"`
	BasePrice   float64 `json:"base_price"`
	PriceEceran float64 `json:"price_eceran"`
	PriceGrosir float64 `json:"price_grosir"`
	CreatedBy   string  `json:"created_by"`
	UpdatedBy   string  `json:"updated_by"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.ProductID,
		arg.Name,
		arg.Brand,
		arg.Description,
		arg.BasePrice,
		arg.PriceEceran,
		arg.PriceGrosir,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteProductByID = `-- name: DeleteProductByID :one
DELETE
FROM products
WHERE id = $1::char(36)
    returning id
`

func (q *Queries) DeleteProductByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteProductByID, id)
	err := row.Scan(&id)
	return id, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id::char(36),
        product_id::char(36),
        name::varchar,
        brand::varchar,
        description::varchar,
        base_price::float,
        price_eceran::float,
        price_grosir::float,
        created_at::timestamp,
        updated_at::timestamp,
        created_by::varchar,
        updated_by::varchar
FROM products
WHERE id = $1::char(36)
`

type GetProductByIDRow struct {
	ID          string    `json:"id"`
	ProductID   string    `json:"product_id"`
	Name        string    `json:"name"`
	Brand       string    `json:"brand"`
	Description string    `json:"description"`
	BasePrice   float64   `json:"base_price"`
	PriceEceran float64   `json:"price_eceran"`
	PriceGrosir float64   `json:"price_grosir"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	CreatedBy   string    `json:"created_by"`
	UpdatedBy   string    `json:"updated_by"`
}

func (q *Queries) GetProductByID(ctx context.Context, productid string) (GetProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, productid)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Brand,
		&i.Description,
		&i.BasePrice,
		&i.PriceEceran,
		&i.PriceGrosir,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id::char(36),
    product_id::char(36),
    name::varchar,
    brand::varchar,
    description::varchar,
    base_price::float,
    price_eceran::float,
    price_grosir::float,
    created_at::timestamp,
    updated_at::timestamp,
    created_by::varchar,
    updated_by::varchar
FROM products
`

type GetProductsRow struct {
	ID          string    `json:"id"`
	ProductID   string    `json:"product_id"`
	Name        string    `json:"name"`
	Brand       string    `json:"brand"`
	Description string    `json:"description"`
	BasePrice   float64   `json:"base_price"`
	PriceEceran float64   `json:"price_eceran"`
	PriceGrosir float64   `json:"price_grosir"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	CreatedBy   string    `json:"created_by"`
	UpdatedBy   string    `json:"updated_by"`
}

func (q *Queries) GetProducts(ctx context.Context) ([]GetProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.Brand,
			&i.Description,
			&i.BasePrice,
			&i.PriceEceran,
			&i.PriceGrosir,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsBySupplierID = `-- name: GetProductsBySupplierID :many
SELECT id::char(36),
        product_id::char(36),
        s_id::char(36),
        name::varchar,
        brand::varchar,
        description::varchar,
        base_price::float,
        price_eceran::float,
        price_grosir::float,
        created_at::timestamp,
        updated_at::timestamp,
        created_by::varchar,
        updated_by::varchar
FROM products where s_id = $1::char(36)
`

type GetProductsBySupplierIDRow struct {
	ID          string    `json:"id"`
	ProductID   string    `json:"product_id"`
	SID         string    `json:"s_id"`
	Name        string    `json:"name"`
	Brand       string    `json:"brand"`
	Description string    `json:"description"`
	BasePrice   float64   `json:"base_price"`
	PriceEceran float64   `json:"price_eceran"`
	PriceGrosir float64   `json:"price_grosir"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	CreatedBy   string    `json:"created_by"`
	UpdatedBy   string    `json:"updated_by"`
}

func (q *Queries) GetProductsBySupplierID(ctx context.Context, sID string) ([]GetProductsBySupplierIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsBySupplierID, sID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsBySupplierIDRow
	for rows.Next() {
		var i GetProductsBySupplierIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.SID,
			&i.Name,
			&i.Brand,
			&i.Description,
			&i.BasePrice,
			&i.PriceEceran,
			&i.PriceGrosir,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductByID = `-- name: UpdateProductByID :one
UPDATE products
SET name= $1:: varchar,
    product_id= $2:: varchar,
    brand= $3:: varchar,
    description = $4:: varchar,
    base_price = $5:: float,
    price_eceran = $6:: float,
    price_grosir = $7:: float,
    updated_at = (now() at time zone 'Asia/Jakarta'):: timestamp,
    updated_by = $8:: varchar
WHERE id = $9:: char (36) returning id::char(36), product_id::char(36),
    name:: varchar, brand::varchar, description::varchar, base_price::float, price_eceran::float, price_grosir::float
    , created_at::timestamp, updated_at::timestamp, created_by::varchar, updated_by::varchar
`

type UpdateProductByIDParams struct {
	Name        string  `json:"name"`
	ProductID   string  `json:"product_id"`
	Brand       string  `json:"brand"`
	Description string  `json:"description"`
	Baseprice   float64 `json:"baseprice"`
	Priceeceran float64 `json:"priceeceran"`
	Pricegrosir float64 `json:"pricegrosir"`
	Updatedby   string  `json:"updatedby"`
	ID          string  `json:"id"`
}

type UpdateProductByIDRow struct {
	ID          string    `json:"id"`
	ProductID   string    `json:"product_id"`
	Name        string    `json:"name"`
	Brand       string    `json:"brand"`
	Description string    `json:"description"`
	BasePrice   float64   `json:"base_price"`
	PriceEceran float64   `json:"price_eceran"`
	PriceGrosir float64   `json:"price_grosir"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	CreatedBy   string    `json:"created_by"`
	UpdatedBy   string    `json:"updated_by"`
}

func (q *Queries) UpdateProductByID(ctx context.Context, arg UpdateProductByIDParams) (UpdateProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateProductByID,
		arg.Name,
		arg.ProductID,
		arg.Brand,
		arg.Description,
		arg.Baseprice,
		arg.Priceeceran,
		arg.Pricegrosir,
		arg.Updatedby,
		arg.ID,
	)
	var i UpdateProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Brand,
		&i.Description,
		&i.BasePrice,
		&i.PriceEceran,
		&i.PriceGrosir,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const updateProductStockByID = `-- name: UpdateProductStockByID :exec
UPDATE products
SET stock= $1:: integer,
    updated_at = (now() at time zone 'Asia/Jakarta'):: timestamp,
    updated_by = $2:: varchar
WHERE id = $3:: char (36)
`

type UpdateProductStockByIDParams struct {
	Stock     int32  `json:"stock"`
	Updatedby string `json:"updatedby"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateProductStockByID(ctx context.Context, arg UpdateProductStockByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateProductStockByID, arg.Stock, arg.Updatedby, arg.ID)
	return err
}

const updateProductStockChildByID = `-- name: UpdateProductStockChildByID :exec
UPDATE products
SET stock= $1:: integer,
    updated_at = (now() at time zone 'Asia/Jakarta'):: timestamp,
    updated_by = $2:: varchar
WHERE product_id = $3:: char (36)
`

type UpdateProductStockChildByIDParams struct {
	Stock     int32  `json:"stock"`
	Updatedby string `json:"updatedby"`
	ProductID string `json:"product_id"`
}

func (q *Queries) UpdateProductStockChildByID(ctx context.Context, arg UpdateProductStockChildByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateProductStockChildByID, arg.Stock, arg.Updatedby, arg.ProductID)
	return err
}
