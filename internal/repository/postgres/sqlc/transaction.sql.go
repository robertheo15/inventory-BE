// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: transaction.sql

package sqlc

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (id,
                          c_id,
                          transaction_id,
                          invoice,
                          status,
                          type,
                          methode,
                          created_at,
                          updated_at,
                          created_by,
                          updated_by)
VALUES (gen_random_uuid(),
        $1::char(36),
        $2::char(36),
        $3::varchar,
        $4::varchar,
        $5::varchar,
        $6::varchar,
        now() at time zone 'Asia/Jakarta',
        now() at time zone 'Asia/Jakarta',
        $7::varchar,
        $8::varchar)
RETURNING id::char(36), invoice::varchar
`

type CreateTransactionParams struct {
	CID           string `json:"c_id"`
	TransactionID string `json:"transaction_id"`
	Invoice       string `json:"invoice"`
	Status        string `json:"status"`
	Type          string `json:"type"`
	Methode       string `json:"methode"`
	CreatedBy     string `json:"created_by"`
	UpdatedBy     string `json:"updated_by"`
}

type CreateTransactionRow struct {
	ID      string `json:"id"`
	Invoice string `json:"invoice"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (CreateTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.CID,
		arg.TransactionID,
		arg.Invoice,
		arg.Status,
		arg.Type,
		arg.Methode,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i CreateTransactionRow
	err := row.Scan(&i.ID, &i.Invoice)
	return i, err
}

const deleteTransactionByID = `-- name: DeleteTransactionByID :one
DELETE
FROM transactions
WHERE id = $1::char(36)
    returning id
`

func (q *Queries) DeleteTransactionByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteTransactionByID, id)
	err := row.Scan(&id)
	return id, err
}

const getTransactionByChildID = `-- name: GetTransactionByChildID :many
SELECT
    id::char(36),
        c_id::char(36),
        transaction_id::char(36),
        invoice::varchar,
        status::varchar,
        type::varchar,
        methode::varchar,
        created_at::timestamp,
        updated_at::timestamp,
        created_by::varchar,
        updated_by::varchar
FROM transactions WHERE transaction_id = $1::char(36)
`

type GetTransactionByChildIDRow struct {
	ID            string    `json:"id"`
	CID           string    `json:"c_id"`
	TransactionID string    `json:"transaction_id"`
	Invoice       string    `json:"invoice"`
	Status        string    `json:"status"`
	Type          string    `json:"type"`
	Methode       string    `json:"methode"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	CreatedBy     string    `json:"created_by"`
	UpdatedBy     string    `json:"updated_by"`
}

func (q *Queries) GetTransactionByChildID(ctx context.Context, transactionID string) ([]GetTransactionByChildIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionByChildID, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionByChildIDRow
	for rows.Next() {
		var i GetTransactionByChildIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CID,
			&i.TransactionID,
			&i.Invoice,
			&i.Status,
			&i.Type,
			&i.Methode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT
    id::char(36),
    c_id::char(36),
    transaction_id::char(36),
    invoice::varchar,
    status::varchar,
    type::varchar,
    methode::varchar,
    created_at::timestamp,
    updated_at::timestamp,
    created_by::varchar,
    updated_by::varchar
FROM transactions WHERE id = $2::char(36) and type = ANY($1::varchar[])
`

type GetTransactionByIDParams struct {
	Column1 []string `json:"column_1"`
	ID      string   `json:"id"`
}

type GetTransactionByIDRow struct {
	ID            string    `json:"id"`
	CID           string    `json:"c_id"`
	TransactionID string    `json:"transaction_id"`
	Invoice       string    `json:"invoice"`
	Status        string    `json:"status"`
	Type          string    `json:"type"`
	Methode       string    `json:"methode"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	CreatedBy     string    `json:"created_by"`
	UpdatedBy     string    `json:"updated_by"`
}

func (q *Queries) GetTransactionByID(ctx context.Context, arg GetTransactionByIDParams) (GetTransactionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, pq.Array(arg.Column1), arg.ID)
	var i GetTransactionByIDRow
	err := row.Scan(
		&i.ID,
		&i.CID,
		&i.TransactionID,
		&i.Invoice,
		&i.Status,
		&i.Type,
		&i.Methode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT id::char(36),
       c_id::char(36),
       transaction_id::char(36),
       invoice::varchar,
       status::varchar,
       type::varchar,
       methode::varchar,
       created_at::timestamp,
       updated_at::timestamp,
       created_by::varchar,
       updated_by::varchar
FROM transactions WHERE type = ANY($1::varchar[])
`

type GetTransactionsRow struct {
	ID            string    `json:"id"`
	CID           string    `json:"c_id"`
	TransactionID string    `json:"transaction_id"`
	Invoice       string    `json:"invoice"`
	Status        string    `json:"status"`
	Type          string    `json:"type"`
	Methode       string    `json:"methode"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	CreatedBy     string    `json:"created_by"`
	UpdatedBy     string    `json:"updated_by"`
}

func (q *Queries) GetTransactions(ctx context.Context, dollar_1 []string) ([]GetTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactions, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionsRow
	for rows.Next() {
		var i GetTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CID,
			&i.TransactionID,
			&i.Invoice,
			&i.Status,
			&i.Type,
			&i.Methode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByStatus = `-- name: GetTransactionsByStatus :many
SELECT  id::char(36),
        c_id::char(36),
        transaction_id::char(36),
        invoice::varchar,
        status::varchar,
        type::varchar,
        methode::varchar,
        created_at::timestamp,
        updated_at::timestamp,
        created_by::varchar,
        updated_by::varchar
FROM transactions WHERE type = ANY($1::varchar[]) and status = $2::varchar
ORDER BY created_at ASC
`

type GetTransactionsByStatusParams struct {
	Column1 []string `json:"column_1"`
	Status  string   `json:"status"`
}

type GetTransactionsByStatusRow struct {
	ID            string    `json:"id"`
	CID           string    `json:"c_id"`
	TransactionID string    `json:"transaction_id"`
	Invoice       string    `json:"invoice"`
	Status        string    `json:"status"`
	Type          string    `json:"type"`
	Methode       string    `json:"methode"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	CreatedBy     string    `json:"created_by"`
	UpdatedBy     string    `json:"updated_by"`
}

func (q *Queries) GetTransactionsByStatus(ctx context.Context, arg GetTransactionsByStatusParams) ([]GetTransactionsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByStatus, pq.Array(arg.Column1), arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionsByStatusRow
	for rows.Next() {
		var i GetTransactionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.CID,
			&i.TransactionID,
			&i.Invoice,
			&i.Status,
			&i.Type,
			&i.Methode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsSupplierByStatus = `-- name: GetTransactionsSupplierByStatus :many
SELECT  t.id::char(36),
        t.c_id::char(36),
        t.transaction_id::char(36),
        t.invoice::varchar,
        t.status::varchar,
        t.type::varchar,
        t.methode::varchar,
        s.brand_name::varchar,
        t.created_at::timestamp,
        t.updated_at::timestamp,
        t.created_by::varchar,
        t.updated_by::varchar
FROM transactions t
     INNER JOIN suppliers s on t.s_id = s.id
WHERE t.type = ANY($1::varchar[]) and t.status = $2::varchar
ORDER BY created_at ASC
`

type GetTransactionsSupplierByStatusParams struct {
	Column1 []string `json:"column_1"`
	Status  string   `json:"status"`
}

type GetTransactionsSupplierByStatusRow struct {
	TID            string    `json:"t_id"`
	TCID           string    `json:"t_c_id"`
	TTransactionID string    `json:"t_transaction_id"`
	TInvoice       string    `json:"t_invoice"`
	TStatus        string    `json:"t_status"`
	TType          string    `json:"t_type"`
	TMethode       string    `json:"t_methode"`
	SBrandName     string    `json:"s_brand_name"`
	TCreatedAt     time.Time `json:"t_created_at"`
	TUpdatedAt     time.Time `json:"t_updated_at"`
	TCreatedBy     string    `json:"t_created_by"`
	TUpdatedBy     string    `json:"t_updated_by"`
}

func (q *Queries) GetTransactionsSupplierByStatus(ctx context.Context, arg GetTransactionsSupplierByStatusParams) ([]GetTransactionsSupplierByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsSupplierByStatus, pq.Array(arg.Column1), arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionsSupplierByStatusRow
	for rows.Next() {
		var i GetTransactionsSupplierByStatusRow
		if err := rows.Scan(
			&i.TID,
			&i.TCID,
			&i.TTransactionID,
			&i.TInvoice,
			&i.TStatus,
			&i.TType,
			&i.TMethode,
			&i.SBrandName,
			&i.TCreatedAt,
			&i.TUpdatedAt,
			&i.TCreatedBy,
			&i.TUpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStatusTransactionByID = `-- name: UpdateStatusTransactionByID :one
UPDATE transactions
SET status = $1::varchar,
    updated_at = (now() at time zone 'Asia/Jakarta')::timestamp,
    updated_by = $2::varchar
WHERE id = $3::char(36) RETURNING
    id::char(36)
`

type UpdateStatusTransactionByIDParams struct {
	Status    string `json:"status"`
	UpdatedBy string `json:"updated_by"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateStatusTransactionByID(ctx context.Context, arg UpdateStatusTransactionByIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, updateStatusTransactionByID, arg.Status, arg.UpdatedBy, arg.ID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateTransactionByID = `-- name: UpdateTransactionByID :one
UPDATE transactions
SET c_id = $1::char(36),
    transaction_id = $2::char(36),
    status = $3::varchar,
    type = $4::varchar,
    methode = $5::varchar,
    updated_at = (now() at time zone 'Asia/Jakarta')::timestamp,
    updated_by = $6::varchar
WHERE id = $7::char(36) RETURNING
    id::char(36),
    c_id::char(36),
    transaction_id::char(36),
    invoice::varchar,
    status::varchar,
    type::varchar,
    methode::varchar,
    created_at::timestamp,
    updated_at::timestamp,
    created_by::varchar,
    updated_by::varchar
`

type UpdateTransactionByIDParams struct {
	CID           string `json:"c_id"`
	TransactionID string `json:"transaction_id"`
	Status        string `json:"status"`
	Type          string `json:"type"`
	Methode       string `json:"methode"`
	UpdatedBy     string `json:"updated_by"`
	ID            string `json:"id"`
}

type UpdateTransactionByIDRow struct {
	ID            string    `json:"id"`
	CID           string    `json:"c_id"`
	TransactionID string    `json:"transaction_id"`
	Invoice       string    `json:"invoice"`
	Status        string    `json:"status"`
	Type          string    `json:"type"`
	Methode       string    `json:"methode"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	CreatedBy     string    `json:"created_by"`
	UpdatedBy     string    `json:"updated_by"`
}

func (q *Queries) UpdateTransactionByID(ctx context.Context, arg UpdateTransactionByIDParams) (UpdateTransactionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateTransactionByID,
		arg.CID,
		arg.TransactionID,
		arg.Status,
		arg.Type,
		arg.Methode,
		arg.UpdatedBy,
		arg.ID,
	)
	var i UpdateTransactionByIDRow
	err := row.Scan(
		&i.ID,
		&i.CID,
		&i.TransactionID,
		&i.Invoice,
		&i.Status,
		&i.Type,
		&i.Methode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}
